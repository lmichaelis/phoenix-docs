{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The ZenGin Reference Welcome to the open ZenGin reference documentation. This page contains information about file format used by ZenGin , a game engine developed by Piranha Bytes for the games Gothic and Gothic II . Prerequisites To properly understand this documentation page, a good understanding of binary data and operations as well as the C programming language is highly useful. Experience with other data exchange formats such as JSON and XML might also be helpful.","title":"The ZenGin Reference"},{"location":"#the-zengin-reference","text":"Welcome to the open ZenGin reference documentation. This page contains information about file format used by ZenGin , a game engine developed by Piranha Bytes for the games Gothic and Gothic II .","title":"The ZenGin Reference"},{"location":"#prerequisites","text":"To properly understand this documentation page, a good understanding of binary data and operations as well as the C programming language is highly useful. Experience with other data exchange formats such as JSON and XML might also be helpful.","title":"Prerequisites"},{"location":"format/fnt/","text":"The FNT file format Font (or FNT ) files contain metadata of fonts for use with the ZenGin . FNT files only contain font metadata which points into a TGA file containing the actual font glyphs. Important FNT files are binary files which are always encoded with the little-endian byte order. The number 0xCAFEBABE will be represented as BE BA FE CA when viewing the file in a hex editor. Font files are structured like this: Font file structure #pragma pack(push, 1) typedef struct vec2 { float u ; float v ; } vec2_t ; struct fnt_file { char version [ 2 ]; // (1) char * font_image ; // (2) uint32_t glyph_height ; // (3) uint32_t glyph_count ; // (4) uint8_t glyph_widths []; // (5) vec2_t glyph_top_left_uvs []; // (6) vec2_t glyph_bottom_right_uvs []; // (7) }; #pragma pack(pop) A fixed string denoting the version of the font file. It's always \"1\\n\" A newline ( \"\\n\" ) terminated string containing the name of the font image file. The height of each glyph in pixels. The number of glyphs stored in this file. An array of length glyph_count containing the width of each glyph. An array of length glyph_count containing the top left UV-coordinate of each glyph. An array of length glyph_count containing the bottom right UV-coordinate of each glyph. Note To get the actual pixel coordinate in the glyph image for any given UV-coordinate, multiply the x UV-coordinate by the width of the image and the y UV-coordinate by the height. Warning Some UV-coordinates are negative. These should be ignored since they don't have a glyph image associated with them. File Location Glyph image files can normally be found in Textures.vdf inside the _WORK/DATA/TEXTURES/FONTS/NOMIP/ ( TGA files) and _WORK/DATA/TEXTURES/_COMPILED/ ( TEX files) folders. The font ( FNT ) files can be found in Textures.vdf inside the _WORK/DATA/TEXTURES/_COMPILED/ folder.","title":"The FNT file format"},{"location":"format/fnt/#the-fnt-file-format","text":"Font (or FNT ) files contain metadata of fonts for use with the ZenGin . FNT files only contain font metadata which points into a TGA file containing the actual font glyphs. Important FNT files are binary files which are always encoded with the little-endian byte order. The number 0xCAFEBABE will be represented as BE BA FE CA when viewing the file in a hex editor. Font files are structured like this: Font file structure #pragma pack(push, 1) typedef struct vec2 { float u ; float v ; } vec2_t ; struct fnt_file { char version [ 2 ]; // (1) char * font_image ; // (2) uint32_t glyph_height ; // (3) uint32_t glyph_count ; // (4) uint8_t glyph_widths []; // (5) vec2_t glyph_top_left_uvs []; // (6) vec2_t glyph_bottom_right_uvs []; // (7) }; #pragma pack(pop) A fixed string denoting the version of the font file. It's always \"1\\n\" A newline ( \"\\n\" ) terminated string containing the name of the font image file. The height of each glyph in pixels. The number of glyphs stored in this file. An array of length glyph_count containing the width of each glyph. An array of length glyph_count containing the top left UV-coordinate of each glyph. An array of length glyph_count containing the bottom right UV-coordinate of each glyph. Note To get the actual pixel coordinate in the glyph image for any given UV-coordinate, multiply the x UV-coordinate by the width of the image and the y UV-coordinate by the height. Warning Some UV-coordinates are negative. These should be ignored since they don't have a glyph image associated with them. File Location Glyph image files can normally be found in Textures.vdf inside the _WORK/DATA/TEXTURES/FONTS/NOMIP/ ( TGA files) and _WORK/DATA/TEXTURES/_COMPILED/ ( TEX files) folders. The font ( FNT ) files can be found in Textures.vdf inside the _WORK/DATA/TEXTURES/_COMPILED/ folder.","title":"The FNT file format"},{"location":"format/tex/","text":"The TEX file format TEX files contain DXT1-5 , palette or raw textures alongside mipmaps of each texture. Texture files are binary files which start with a header after followed by palette and image data. Important TEX files are binary files which are always encoded with the little-endian byte order. The number 0xCAFEBABE will be represented as BE BA FE CA when viewing the file in a hex editor. The header has a structure as follows: ZTEX header structure #pragma pack(push, 1) typedef enum ztex_format { tex_bgra8 = ( uint32_t ) 0 , // (1) tex_rgba8 = ( uint32_t ) 1 , // (2) tex_abgr8 = ( uint32_t ) 2 , // (3) tex_argb8 = ( uint32_t ) 3 , // (4) tex_bgr8 = ( uint32_t ) 4 , // (5) tex_rgb8 = ( uint32_t ) 5 , // (6) tex_argb4 = ( uint32_t ) 6 , // (7) tex_a1rgb5 = ( uint32_t ) 7 , // (8) tex_r5g6b5 = ( uint32_t ) 8 , // (9) tex_p8 = ( uint32_t ) 9 , // (10) tex_dxt1 = ( uint32_t ) 10 , // (11) tex_dxt2 = ( uint32_t ) 11 , // (12) tex_dxt3 = ( uint32_t ) 12 , // (13) tex_dxt4 = ( uint32_t ) 13 , // (14) tex_dxt5 = ( uint32_t ) 14 , // (15) } ztex_format_t ; struct ztex_header { char magic [ 4 ]; // (16) uint32_t version ; // (17) ztex_format_t format ; // (18) uint32_t width ; // (19) uint32_t height ; // (20) uint32_t mipmap_count ; // (21) uint32_t reference_width ; // (22) uint32_t reference_height ; // (23) uint32_t average_color ; // (24) }; #pragma pack(pop) 32-bit ARGB pixel format with alpha, using 8 bits per channel 32-bit ARGB pixel format with alpha, using 8 bits per channel 32-bit ARGB pixel format with alpha, using 8 bits per channel 32-bit ARGB pixel format with alpha, using 8 bits per channel 24-bit RGB pixel format with 8 bits per channel 24-bit RGB pixel format with 8 bits per channel 16-bit ARGB pixel format with 4 bits for each channel 16-bit ARGB pixel format where 5 bits are reserved for each color and 1 bit is reserved for alpha 16-bit RGB pixel format with 5 bits for red, 6 bits for green, and 5 bits for blue 8-bit color indexed DXT1 compression texture format DXT2 compression texture format DXT3 compression texture format DXT4 compression texture format DXT5 compression texture format The ZTEX magic value. Always \"ZTEX\" . The version of the ZTEX format used. Always 0 . A 32-bit integer indicating the image data format used. The width of the original image in pixels. The height of the original image in pixels. The number of mipmap of the original stored. Purpose unknown. The name was adopted from ZenLib . Purpose unknown. The name was adopted from ZenLib . A 32-bit ARGB value containing the average color of the image. Note All color values should be understood as word-order , so an RGBA color #aabbccdd would be represented as the bytes dd cc bb aa in little-endian byte order. An alpha byte of 0xff means full opacity. Mipmaps Mipmaps are stored from the smallest to the largest image. If the mipmap-image with the level 0 has a with of w and a height of h pixels then the mipmap image with the level n has a width of w >> n and a height of h >> n pixels (each mipmap-level is half the size of the previous one). DXT If the texture format is dxt1 , dxt2 , dxt3 , dxt4 or dxt5 the data stored right after the header is DXT compressed. To figure out the size of each mipmap-level in bytes, for DXT1 compressed data calculate max(1, w / 4) * max(1, h / 4) * 8 1 and for DXT2-DXT5 calculate max(1, w / 4) * max(1, h / 4) * 16 1 where w and h depend on the mipmap level. In practice, only DXT1, DXT3 AND DXT5 are used. Palette With the tex_p8 format, the texture file contains a palette-list before the actual texture data. This palette follows right after the header and contains 256 32-bit ARGB8 colors. These are then referenced in the texture data section right after the palette data. Each byte in the texture data represents one pixel. Its color is the color in the palette at the index indicated by the byte's value. Raw If the format is not tex_p8 and not one of the dxt formats, the texture stores raw data according to the format described above. For tex_bgra8 , tex_rgba8 , tex_abgr8 and tex_argb8 formats, each pixel is 4 bytes in size. With formats tex_bgr8 and tex_rgb8 , each pixel is 3 bytes in size. tex_argb4 , tex_a1rgb5 and tex_r5g6b5 contain 2-byte sized pixels. This calculation has been adopted from ZenLib . \u21a9 \u21a9","title":"The TEX file format"},{"location":"format/tex/#the-tex-file-format","text":"TEX files contain DXT1-5 , palette or raw textures alongside mipmaps of each texture. Texture files are binary files which start with a header after followed by palette and image data. Important TEX files are binary files which are always encoded with the little-endian byte order. The number 0xCAFEBABE will be represented as BE BA FE CA when viewing the file in a hex editor. The header has a structure as follows: ZTEX header structure #pragma pack(push, 1) typedef enum ztex_format { tex_bgra8 = ( uint32_t ) 0 , // (1) tex_rgba8 = ( uint32_t ) 1 , // (2) tex_abgr8 = ( uint32_t ) 2 , // (3) tex_argb8 = ( uint32_t ) 3 , // (4) tex_bgr8 = ( uint32_t ) 4 , // (5) tex_rgb8 = ( uint32_t ) 5 , // (6) tex_argb4 = ( uint32_t ) 6 , // (7) tex_a1rgb5 = ( uint32_t ) 7 , // (8) tex_r5g6b5 = ( uint32_t ) 8 , // (9) tex_p8 = ( uint32_t ) 9 , // (10) tex_dxt1 = ( uint32_t ) 10 , // (11) tex_dxt2 = ( uint32_t ) 11 , // (12) tex_dxt3 = ( uint32_t ) 12 , // (13) tex_dxt4 = ( uint32_t ) 13 , // (14) tex_dxt5 = ( uint32_t ) 14 , // (15) } ztex_format_t ; struct ztex_header { char magic [ 4 ]; // (16) uint32_t version ; // (17) ztex_format_t format ; // (18) uint32_t width ; // (19) uint32_t height ; // (20) uint32_t mipmap_count ; // (21) uint32_t reference_width ; // (22) uint32_t reference_height ; // (23) uint32_t average_color ; // (24) }; #pragma pack(pop) 32-bit ARGB pixel format with alpha, using 8 bits per channel 32-bit ARGB pixel format with alpha, using 8 bits per channel 32-bit ARGB pixel format with alpha, using 8 bits per channel 32-bit ARGB pixel format with alpha, using 8 bits per channel 24-bit RGB pixel format with 8 bits per channel 24-bit RGB pixel format with 8 bits per channel 16-bit ARGB pixel format with 4 bits for each channel 16-bit ARGB pixel format where 5 bits are reserved for each color and 1 bit is reserved for alpha 16-bit RGB pixel format with 5 bits for red, 6 bits for green, and 5 bits for blue 8-bit color indexed DXT1 compression texture format DXT2 compression texture format DXT3 compression texture format DXT4 compression texture format DXT5 compression texture format The ZTEX magic value. Always \"ZTEX\" . The version of the ZTEX format used. Always 0 . A 32-bit integer indicating the image data format used. The width of the original image in pixels. The height of the original image in pixels. The number of mipmap of the original stored. Purpose unknown. The name was adopted from ZenLib . Purpose unknown. The name was adopted from ZenLib . A 32-bit ARGB value containing the average color of the image. Note All color values should be understood as word-order , so an RGBA color #aabbccdd would be represented as the bytes dd cc bb aa in little-endian byte order. An alpha byte of 0xff means full opacity.","title":"The TEX file format"},{"location":"format/tex/#mipmaps","text":"Mipmaps are stored from the smallest to the largest image. If the mipmap-image with the level 0 has a with of w and a height of h pixels then the mipmap image with the level n has a width of w >> n and a height of h >> n pixels (each mipmap-level is half the size of the previous one).","title":"Mipmaps"},{"location":"format/tex/#dxt","text":"If the texture format is dxt1 , dxt2 , dxt3 , dxt4 or dxt5 the data stored right after the header is DXT compressed. To figure out the size of each mipmap-level in bytes, for DXT1 compressed data calculate max(1, w / 4) * max(1, h / 4) * 8 1 and for DXT2-DXT5 calculate max(1, w / 4) * max(1, h / 4) * 16 1 where w and h depend on the mipmap level. In practice, only DXT1, DXT3 AND DXT5 are used.","title":"DXT"},{"location":"format/tex/#palette","text":"With the tex_p8 format, the texture file contains a palette-list before the actual texture data. This palette follows right after the header and contains 256 32-bit ARGB8 colors. These are then referenced in the texture data section right after the palette data. Each byte in the texture data represents one pixel. Its color is the color in the palette at the index indicated by the byte's value.","title":"Palette"},{"location":"format/tex/#raw","text":"If the format is not tex_p8 and not one of the dxt formats, the texture stores raw data according to the format described above. For tex_bgra8 , tex_rgba8 , tex_abgr8 and tex_argb8 formats, each pixel is 4 bytes in size. With formats tex_bgr8 and tex_rgb8 , each pixel is 3 bytes in size. tex_argb4 , tex_a1rgb5 and tex_r5g6b5 contain 2-byte sized pixels. This calculation has been adopted from ZenLib . \u21a9 \u21a9","title":"Raw"},{"location":"format/vdf/","text":"The VDF file format VDF is a container format for a file/directory structure, similar to the tar format . VDF files are not intended to be used for general file transfer, and thus they don't contain metadata like permission information which can usually be found in such container formats. VDF files consist of a header , the catalog and a data section which are described below. Important VDF files are binary files which are always encoded with the little-endian byte order. The number 0xCAFEBABE will be represented as BE BA FE CA when viewing the file in a hex editor. Header The VDF 's header describes the file and its contents. It always has the same physical size and can be represented as a C struct like this. VDF Header #pragma pack(push, 1) struct vdf_header { char comment [ 256 ]; // (1) char signature [ 16 ]; // (2) uint32_t file_count ; uint32_t entry_count ; uint32_t timestamp ; // (3) uint32_t size ; // (4) uint32_t catalog_offset ; // (5) uint32_t version ; // (6) }; #pragma pack(pop) The comment might not fill the entire 256 bytes. If it does not, the rest of the array is filled with '\\x1A' characters. The signature indicates which game this VDF file was made for. If it is \"PSVDSC_V2.00\\r\\n\\r\\n\" then the VDF was made for Gothic and if it is \"PSVDSC_V2.00\\n\\r\\n\\r\" it was made for Gothic II . The timestamp has a special format called \"DOS date format\" by all sources 1 . It is described below . The full size of the file in bytes. An offset from the beginning of the file in bytes at which the first entry of the catalog is located. The version of the VDF format being used. This is always 0x50 in reality. Note This is a packed structure. Catalog The catalog describes the directory and file structure contained within the VDF file. Each entry is either a file or a directory entry. File entries always point to an address in the data section of the container while directory entries always point to a subsection of the catalog listing the child entries of the directory. Here's a basic example: 00 _WORK/ -> 01 01 DATA/ -> 03 02 CUSTOM/ -> 10 03 ANIMS/ -> 05 04 TEXTURES/ -> 07 05 ANIM1.MAN 06 ANIM2.MAN 07 TEXTURE_A.TEX 08 TEXTURE_B.TEX 09 TEXTURE_C.TEX 10 MYFILE.WAV As you can see, the full path of ANIM1.MAN would be _WORK/DATA/ANIMS/ANIM1.MAN . Notice that all entries of a directory are always listed right after each other, and their respective child entries are listed after the parent folder's entries. Each entry can be represented as a C struct like this. VDF Entry #pragma pack(push, 1) struct vdf_entry { char name [ 64 ]; // (1) uint32_t offset ; // (2) uint32_t size ; // (3) uint32_t type ; // (4) uint32_t attributes ; // (5) }; #pragma pack(pop) The name might not fill the entire 64 bytes. If it does not, the rest of the array is filled with '\\x20' characters. If the entry is a file, this contains an offset into the file at which the entry's data is stored. If it is a directory, this contains the index of the first child entry in the catalog. The size of the entry if it is a file, otherwise contains 0. A bitmask describing the type of the entry. If bit 0x80000000 is set, the entry is a directory, otherwise it is a file. If bit 0x40000000 is set, the entry is the last in the parent directory 2 . Extra attributes for the entry. Unused. Note This is a packed structure. DOS date format The timestamp format used for VDF files has been called DOS date format 1 , however I can not find any official reference for it online. In any case, these timestamps are saved in a 32-bit unsigned integer and formatted like this. DOS date format // year (1) day minute // --------- ----- ------ uint32_t date = 0x2D65BBB3 == 0b0010110'1011'00101'10111'011101'10011 // ---- ----- ----- // month (2) hour second (3) The number of years after 1980, here 1980 + 0b0010110 = 2002 The month starts counting a 1 (January), here 11 = November Seconds are only stored with half-precision so to get the correct number, the number has to be multiplied by two, here 0b10011 * 2 = 38 This reference implementation can be used to load and create DOS timestamps. It is heavily based on the implementation in PhysicsFS . DOS date format reference implementation /** * Converts a DOS timestamp to a standard unix timestamp. */ time_t dos_to_unix_time ( uint32_t dos ) { struct tm t {}; t . tm_year = (( int ) (( dos >> 25 ) & 0x7F )) + 80 ; t . tm_mon = (( int ) (( dos >> 21 ) & 0x0F )) - 1 ; t . tm_mday = ( int ) (( dos >> 16 ) & 0x1F ); t . tm_hour = ( int ) (( dos >> 11 ) & 0x1F ); t . tm_min = ( int ) (( dos >> 5 ) & 0x3F ); t . tm_sec = (( int ) (( dos >> 0 ) & 0x1F )) * 2 ; return timegm ( & t ); } /** * Converts a unix timestamp to a DOS timestamp. */ uint32_t unix_time_to_dos ( time_t nix ) { struct tm * t { gmtime ( & nix )}; uint32_t dos { 0 }; dos |= ( t -> tm_year - 80 ) << 25 ; dos |= ( t -> tm_mon + 1 ) << 21 ; dos |= t -> tm_mday << 16 ; dos |= t -> tm_hour << 11 ; dos |= t -> tm_min << 5 ; dos |= ( t -> tm_sec / 2 ) << 0 ; return dos ; } References to the DOS date format can be found in PhysicsFS where the VDF format is implemented . It is also discussed in the Wiki for ReGoth (the old repository). \u21a9 \u21a9 Referring back to the example, the 0x40000000 bit will be set for entries _WORK/ ( 00 ), CUSTOM/ ( 02 ), TEXTURES/ ( 04 ), ANIM2.MAN ( 06 ), TEXTURE_C.TEX ( 09 ) and MYFILE.WAV ( 10 ). \u21a9","title":"The VDF file format"},{"location":"format/vdf/#the-vdf-file-format","text":"VDF is a container format for a file/directory structure, similar to the tar format . VDF files are not intended to be used for general file transfer, and thus they don't contain metadata like permission information which can usually be found in such container formats. VDF files consist of a header , the catalog and a data section which are described below. Important VDF files are binary files which are always encoded with the little-endian byte order. The number 0xCAFEBABE will be represented as BE BA FE CA when viewing the file in a hex editor.","title":"The VDF file format"},{"location":"format/vdf/#header","text":"The VDF 's header describes the file and its contents. It always has the same physical size and can be represented as a C struct like this. VDF Header #pragma pack(push, 1) struct vdf_header { char comment [ 256 ]; // (1) char signature [ 16 ]; // (2) uint32_t file_count ; uint32_t entry_count ; uint32_t timestamp ; // (3) uint32_t size ; // (4) uint32_t catalog_offset ; // (5) uint32_t version ; // (6) }; #pragma pack(pop) The comment might not fill the entire 256 bytes. If it does not, the rest of the array is filled with '\\x1A' characters. The signature indicates which game this VDF file was made for. If it is \"PSVDSC_V2.00\\r\\n\\r\\n\" then the VDF was made for Gothic and if it is \"PSVDSC_V2.00\\n\\r\\n\\r\" it was made for Gothic II . The timestamp has a special format called \"DOS date format\" by all sources 1 . It is described below . The full size of the file in bytes. An offset from the beginning of the file in bytes at which the first entry of the catalog is located. The version of the VDF format being used. This is always 0x50 in reality. Note This is a packed structure.","title":"Header"},{"location":"format/vdf/#catalog","text":"The catalog describes the directory and file structure contained within the VDF file. Each entry is either a file or a directory entry. File entries always point to an address in the data section of the container while directory entries always point to a subsection of the catalog listing the child entries of the directory. Here's a basic example: 00 _WORK/ -> 01 01 DATA/ -> 03 02 CUSTOM/ -> 10 03 ANIMS/ -> 05 04 TEXTURES/ -> 07 05 ANIM1.MAN 06 ANIM2.MAN 07 TEXTURE_A.TEX 08 TEXTURE_B.TEX 09 TEXTURE_C.TEX 10 MYFILE.WAV As you can see, the full path of ANIM1.MAN would be _WORK/DATA/ANIMS/ANIM1.MAN . Notice that all entries of a directory are always listed right after each other, and their respective child entries are listed after the parent folder's entries. Each entry can be represented as a C struct like this. VDF Entry #pragma pack(push, 1) struct vdf_entry { char name [ 64 ]; // (1) uint32_t offset ; // (2) uint32_t size ; // (3) uint32_t type ; // (4) uint32_t attributes ; // (5) }; #pragma pack(pop) The name might not fill the entire 64 bytes. If it does not, the rest of the array is filled with '\\x20' characters. If the entry is a file, this contains an offset into the file at which the entry's data is stored. If it is a directory, this contains the index of the first child entry in the catalog. The size of the entry if it is a file, otherwise contains 0. A bitmask describing the type of the entry. If bit 0x80000000 is set, the entry is a directory, otherwise it is a file. If bit 0x40000000 is set, the entry is the last in the parent directory 2 . Extra attributes for the entry. Unused. Note This is a packed structure.","title":"Catalog"},{"location":"format/vdf/#dos-date-format","text":"The timestamp format used for VDF files has been called DOS date format 1 , however I can not find any official reference for it online. In any case, these timestamps are saved in a 32-bit unsigned integer and formatted like this. DOS date format // year (1) day minute // --------- ----- ------ uint32_t date = 0x2D65BBB3 == 0b0010110'1011'00101'10111'011101'10011 // ---- ----- ----- // month (2) hour second (3) The number of years after 1980, here 1980 + 0b0010110 = 2002 The month starts counting a 1 (January), here 11 = November Seconds are only stored with half-precision so to get the correct number, the number has to be multiplied by two, here 0b10011 * 2 = 38 This reference implementation can be used to load and create DOS timestamps. It is heavily based on the implementation in PhysicsFS . DOS date format reference implementation /** * Converts a DOS timestamp to a standard unix timestamp. */ time_t dos_to_unix_time ( uint32_t dos ) { struct tm t {}; t . tm_year = (( int ) (( dos >> 25 ) & 0x7F )) + 80 ; t . tm_mon = (( int ) (( dos >> 21 ) & 0x0F )) - 1 ; t . tm_mday = ( int ) (( dos >> 16 ) & 0x1F ); t . tm_hour = ( int ) (( dos >> 11 ) & 0x1F ); t . tm_min = ( int ) (( dos >> 5 ) & 0x3F ); t . tm_sec = (( int ) (( dos >> 0 ) & 0x1F )) * 2 ; return timegm ( & t ); } /** * Converts a unix timestamp to a DOS timestamp. */ uint32_t unix_time_to_dos ( time_t nix ) { struct tm * t { gmtime ( & nix )}; uint32_t dos { 0 }; dos |= ( t -> tm_year - 80 ) << 25 ; dos |= ( t -> tm_mon + 1 ) << 21 ; dos |= t -> tm_mday << 16 ; dos |= t -> tm_hour << 11 ; dos |= t -> tm_min << 5 ; dos |= ( t -> tm_sec / 2 ) << 0 ; return dos ; } References to the DOS date format can be found in PhysicsFS where the VDF format is implemented . It is also discussed in the Wiki for ReGoth (the old repository). \u21a9 \u21a9 Referring back to the example, the 0x40000000 bit will be set for entries _WORK/ ( 00 ), CUSTOM/ ( 02 ), TEXTURES/ ( 04 ), ANIM2.MAN ( 06 ), TEXTURE_C.TEX ( 09 ) and MYFILE.WAV ( 10 ). \u21a9","title":"DOS date format"},{"location":"format/zen/","text":"The ZEN archive format ZenGin archives ( ZEN files) contain generic data for use with the ZenGin . Most archives store key-value pairs organized into objects, similar to JSON . Archives have three different encodings: binary archives store unannotated bytes, safe binary archives store binary data annotated with field types and names and ascii archives contain a human-readable form of the same data stored in safe binary archives. General Concepts A basic ZEN file might look like this. Example ZEN archive (ASCII) ZenGin Archive ver 1 zCArchiverGeneric ASCII saveGame 0 date 17.9.2002 15:21:1 user mario.roeske END objects 7 END [% oCWorld:zCWorld 64513 0] [VobTree % 0 0] childs0=int:1 [% zCVob 39168 1] pack=int:0 presetName=string:LIGHT bbox3DWS=rawFloat:334.003906 -443.912476 -7493.55371 2734.00391 1956.08765 -5093.55371 trafoOSToWSRot=raw:974226bf00000000a9a9423f000000000000803f00000000a9a942bf00000000974226bf trafoOSToWSPos=vec3:1534.00403 756.087585 -6293.55371 vobName=string:LIGHT visual=string: showVisual=bool:0 visualCamAlign=enum:0 visualAniMode=enum:0 visualAniModeStrength=float:0 vobFarClipZScale=float:1 cdStatic=bool:0 cdDyn=bool:0 staticVob=bool:1 dynShadow=enum:0 zbias=int:1 isAmbient=bool:0 [visual % 0 0] [] [ai % 0 0] [] [] [] [] At the beginning of the file, the header is defined. It consists of two parts, the first one being the same across all encoding and the second being specific to the encoding used. The data content of the file starts right after the second END . The first line of the file's content, [% oCWorld:zCWorld 64513 0] , marks the start of a new object while the last line, [] marks the end of an object . Each object can contain multiple entries alongside other objects . Each entry has a name, a type and a value. This only applies to ascii and safe binary encodings. Header The header of ZEN archives consists of two parts. The first has the same structure for every archive and the second differs between encodings. The first part of the header looks like this. Variable elements of the header have been replaced by <...> placeholders. Example ZEN archive header ZenGin Archive ver 1 <archiver> <encoding> saveGame <issave> date <timestamp> user <username> END Line breaks denote only one newline ( \\n ) character. The <archiver> is a string value, being either zCArchiverGeneric or zCArchiverBinSafe , in reference to the names of the ZEN archive parser classes in the original source code. <encoding> specifies the type of archive in the file. It is either ASCII (for ascii encoded archives), BINARY (for binary encoded archives) or BIN_SAFE (for safe binary encoded archives). If the archive is a save game file <issave> is set to 1 , otherwise it is 0 . <timestamp> denotes the date and time the archive was created. It follows the strptime format %d.%m.%Y %H:%M:%S . <username> is the name of the user (originally the windows account name) the archive was created by. For save games this contains the name of the user who saved the game. Refer to the example above for a filled-out version of the header. The encoding-specific headers follow directly after the END\\n line of the first header as can be seen in the example. Objects Objects in ZEN archives consist of an object name , a class name , a version identifier and an index . The object name is used to describe a unique sub-object of another while the class name is used to identify the type of the object. A ZEN archive object [visual zCParticleFX 0 6] describes a specific sub-object visual of type zCParticleFX meaning it has a set of entries consistent with the definition of a zCParticleFX . Objects without an object name just contain a % instead. Objects always end with [] . Note This behavior can be seen in the example above . Every object with the class name zCVob has the same set of entries as shown in the example. Danger The object name must be unique within each sub-object. A ZEN archive like this is invalid. [% oCWorld:zCWorld 64513 0] [VobTree % 0 0] [] [VobTree % 0 0] [] [] Class names originally referenced a specific class in C++-code. These classes were polymorphic so an object with a class name zCVobLight:zCVob contains both entries of type zCVob and zCVobLight . The entries of the super-class always precede the entries of the subclass, so the zCVobLight:zCVob would first contain all entries of zCVob and then all entries of zCVobLight . Objects without a class name just contain a % instead. Warning Class and object names may not contain spaces. The version of an object is a 32-bit unsigned number which denotes the version of the bottom-most subclass. The version of object [% oCMobInter:oCMOB:zCVob 35585 0] would be 35585 . This version, however, only refers to the oCMobInter -part. Danger This leads to issues when trying to determine whether an object uses the Gothic or the Gothic II definition. If the structure for oCMobInter did not change between the games, the version will be the same. This is not necessarily true for zVob though. Its definition might have changed but this change is not reflected in the version field of the object. The index field of the object is a 32-bit unsigned number which increments for every object with a class name in the archive. In the example this can be seen with the objects [% oCWorld:zCWorld 64513 0] and [% zCVob 39168 1] . Objects without a class name have an index of 0 . Entries The concept of entries only really applies to archives with ascii or safe binary encoding. An entry originally represented a field in a C++-class which defined an object . For this reason, each entry has a name, a type and a value. The following entry types are supported: Type Name Type ID 1 Description string 1 ISO-8859-1 encoded text int 2 A 32-bit signed integer float 3 An IEEE 754 floating-point number byte 4 An 8-bit unsigned integer word 5 An 16-bit unsigned integer bool 6 An boolean value 2 vec3 7 A set of 3 IEEE 754 floating-point numbers color 8 A set of 4 8-bit unsigned integers raw 9 A set of an arbitrary amount of 8-bit unsigned integers rawFloat 16 A set of an arbitrary amount of IEEE 754 floating-point numbers enum 17 A 32-bit unsigned integer 3 hash 18 A 32-bit unsigned integer; specific to the safe binary encoding ASCII ASCII-archives are human-readable ZEN archives, comparable to JSON. Contrary to its name, the file is not actually using the ASCII text encoding. Rather these files are encoded in ISO-8859-1 or alternatively Windows-1252 (because the characters used are encoded identically). ASCII ZEN-archives use a line-based format. Every line after the header contains exactly one object start statement, entry statement or object end token. Leading whitespace is ignored. Header The encoding specific header for the ASCII -encoding looks like this. Variable elements of the header have been replaced by <...> placeholders. objects <count> END <count> denotes the total number of objects in the archive. Refer to the example above for a filled-out version of the header. Objects As stated above, objects in ASCII-ZENs start with a line [% oCWorld:zCWorld 64513 0] defined as [<object name> <class name> <version> <index>] . This is explained further in the section about objects . Entries Entries in ASCII-ZENs follow the format <name>:<type>=<value> where <name> is a C++ identifier, <type> is one of the type names mentioned in the entries section with the exclusion of the hash type. <value> depends on the given type. It has the following formats: Type Name Format Regex Example string An unlimited number of characters excluding newline characters ^[^\\n\\r]* field=string:This is a string int A decimal 32-bit integer ^[+-]?\\d+$ field=int:199 float A decimal floating point value with decimal separator . ^[+-]?(\\d+\\.)?\\d+$ field=float:-1.0 byte A decimal 8-bit unsigned integer ^\\d{1,3}$ field=byte:255 word A decimal 16-bit unsigned integer ^\\d+$ field=word:1001 bool A decimal 1-bit integer ^[01]$ field=bool:1 vec3 A set of three floating point values ^[+-]?(\\d+\\.)?\\d+ [+-]?(\\d+\\.)?\\d+ [+-]?(\\d+\\.)?\\d+$ field=vec3:1.0 -0.1 +100 color A set of four 8-bit unsigned integers ^\\d{1,3} \\d{1,3} \\d{1,3} \\d{1,3}$ field=color:100 0 255 12 raw An unlimited number of hexadecimal bytes ^([0-9A-Fa-f]{2})* field=raw:0fac3256b1 rawFloat An unlimited number of floating point values ^([+-]?(\\d+\\.)?\\d+ )* field=rawFloat:1.0 -100 enum A decimal 32-bit unsigned integer ^\\d+$ field=enum:10 Binary Binary archives are little more than containers for raw bytes. They don't actually contain key-value pairs and they don't allow for nesting objects. Header The encoding specific header for the Binary -encoding is the same as that of the ascii encoding. Variable elements of the header have been replaced by <...> placeholders. objects <count> END <count> denotes the total number of objects in the archive. Objects Objects in binary ZENs don't work like they do in the ascii and safe binary encodings. No object end marker is stored and the beginning of an object does not follow the same format. Binary ZEN object begin structure #pragma pack(push, 1) struct zen_object_begin { uint32_t object_size ; // (1) uint16_t version ; // (2) uint32_t index ; // (3) char * object_name ; // Note: (4) char * class_name ; // Note: (5) }; #pragma pack(pop) Contains the size of the object in bytes, including the header. The version number of the object as described in Objects The index of the object as described in Objects The object name of the object as described in Objects . This insinuates that the string ends with a null-termination character ( \\0 ). In fact, it ends with a newline character ( \\n ), however! The class name of the object as described in Objects . This insinuates that the string ends with a null-termination character ( \\0 ). In fact, it ends with a newline character ( \\n ), however! Entries Binary ZENs just contains packed bytes with no added type annotations. This makes it very difficult to determine the layout of structures within it without having access to the original source code. To read an integer from a binary ZEN for example, the next four bytes are read in literally like this (assuming a little-endian architecture). Binary ZEN entry read scalar example int32_t zen_binary_read_int ( FILE * fp ) { int32_t value = 0 ; fread ( & value , sizeof ( value ), 1 , fp ); return value ; } On big-endian architectures, the value read would have to be transformed to little-endian afterwards. This method of extracting values from binary ZENs is also used for aggregate types, like the vec3 . Instead of reading just one float from the input, three are read like this. Binary ZEN entry read vector example typedef struct vec3 { float x ; float y ; float z ; } vec3_t ; vec3_t zen_binary_read_int ( FILE * fp ) { vec3_t value ; fread ( & value . x , sizeof ( float ), 1 , fp ); fread ( & value . y , sizeof ( float ), 1 , fp ); fread ( & value . z , sizeof ( float ), 1 , fp ); return value ; } Refer to the following chart for type sizes. Type Name C-equivalent Byte Count string char[] 1 * n int int32_t 4 float float 4 byte uint8_t 1 word uint16_t 2 bool uint8_t 1 vec3 struct { float, float, float } 4 * 3 color struct { uint8_t, uint8_t, uint8_t, uint8_t } 1 * 4 raw uint8_t[] 1 * n rawFloat float[] 4 * n enum uint32_t 4 Safe Binary Safe binary archives store binary values annotated with field types and names. They are the most prevalent types of archives and also the ones in which world data is stored. The values of entries as well as their prefixes are stored in a packed binary format. This encoding is not fully reverse-engineered. Header The header of safe binary archives is also binary and has the following structure. Safe binary ZEN header structure #pragma pack(push, 1) struct zen_binsafe_header { uint32_t bs_version ; // (1) uint32_t object_count ; // (2) uint32_t hash_table_offset ; // (3) }; #pragma pack(pop) A separate version identifier for the version of the safe binary encoding used. The total number of objects in the archive The offset of the hash table from the beginning of the file in bytes; discussed below. In addition to the secondary header, safe binary archives also contain a so-called hash table 4 which stores field name information. The hash table is a binary structure as well; it looks like this. Safe binary ZEN hash table structure #pragma pack(push, 1) struct zen_binsafe_hashtable_entry { uint16_t name_length ; // (1) uint16_t insertion_index ; // (2) uint32_t hash_value ; // (3) char name []; // (4) }; struct zen_binsafe_hashtable { uint32_t size ; // (5) zen_binsafe_hashtable_entry entries []; // (6) }; #pragma pack(pop) The length of the name string at the end of the structure. The index of this entry in the hashtable entries member array. The hash value of the entry. Its purpose is currently unknown. The name of the entry. This name is the field name of the entry as explained below. The number of entries in the hash table. Corresponds with the length of the entries member array. An array of all hash table entries; unordered. Objects In safe binary ZENs, objects are handled in almost the same way entries are. Objects definitions are preceded by the string type identifier \\x01 and a 16-bit string length value. The value of this string is the same as the object definition for ASCII-ZENs: Objects start with a line [% oCWorld:zCWorld 64513 0] defined as [<object name> <class name> <version> <index>] . This is explained further in the section about objects . A full object definition might look like this: \\x01\\x1B\\x00[% oCWorld:zCWorld 64513 0] . Note Note that objects are never preceded by a field name like entries are. Entries Every entry in safe binary ZENs is preceded by a field name index and a type identifier including a length if applicable. File name indexes start with a \\x12 which is followed by a 32-bit unsigned integer, indicating an index into the hash table discussed above. The name of the hash table entry at that index is the name of the field. A boolean entry in this format might look like \\x12\\x01\\x00\\00\\x00\\x06\\x01\\x00\\x00\\x00 . It hashtable index is 1 and its value is true . Type IDs are always uint8_t s and hashtable indices are always uint32_t s. Reference the table below for all types in safe binary archives. Type Name Type ID Has Length? C-equivalent Byte Count string 1 Yes char[] 1 * n int 2 No int32_t 4 float 3 No float 4 byte 4 No uint8_t 1 word 5 No uint16_t 2 bool 6 No uint32_t 4 vec3 7 No struct { float, float, float } 4 * 3 color 8 No struct { uint8_t, uint8_t, uint8_t, uint8_t } 1 * 4 raw 9 Yes uint8_t[] 1 * n rawFloat 16 Yes float[] 4 * n enum 17 No uint32_t 4 Note Entries with a length prefix, are encoded like this: \\x12\\x01\\x00\\00\\x00\\x01\\x0D\\x00Hello, world! . It hashtable index is 1 , its length is 0x0D and its value is Hello, World! . Note that the length is always a uint16_t and always follows directly after the type ID. The type index is relevant only for safe binary encoded archives. \u21a9 The actual representation of this value changes between encodings. With the safe binary encoding a boolean value is represented as a 32-bit unsigned integer while it is represented as an 8-bit integer in the binary encoding. \u21a9 Enums represent an actual enumeration value in C++-code. \u21a9 The origin of that name is unknown. It has been used in ZenLib to describe this element of the format. \u21a9","title":"The ZEN archive format"},{"location":"format/zen/#the-zen-archive-format","text":"ZenGin archives ( ZEN files) contain generic data for use with the ZenGin . Most archives store key-value pairs organized into objects, similar to JSON . Archives have three different encodings: binary archives store unannotated bytes, safe binary archives store binary data annotated with field types and names and ascii archives contain a human-readable form of the same data stored in safe binary archives.","title":"The ZEN archive format"},{"location":"format/zen/#general-concepts","text":"A basic ZEN file might look like this. Example ZEN archive (ASCII) ZenGin Archive ver 1 zCArchiverGeneric ASCII saveGame 0 date 17.9.2002 15:21:1 user mario.roeske END objects 7 END [% oCWorld:zCWorld 64513 0] [VobTree % 0 0] childs0=int:1 [% zCVob 39168 1] pack=int:0 presetName=string:LIGHT bbox3DWS=rawFloat:334.003906 -443.912476 -7493.55371 2734.00391 1956.08765 -5093.55371 trafoOSToWSRot=raw:974226bf00000000a9a9423f000000000000803f00000000a9a942bf00000000974226bf trafoOSToWSPos=vec3:1534.00403 756.087585 -6293.55371 vobName=string:LIGHT visual=string: showVisual=bool:0 visualCamAlign=enum:0 visualAniMode=enum:0 visualAniModeStrength=float:0 vobFarClipZScale=float:1 cdStatic=bool:0 cdDyn=bool:0 staticVob=bool:1 dynShadow=enum:0 zbias=int:1 isAmbient=bool:0 [visual % 0 0] [] [ai % 0 0] [] [] [] [] At the beginning of the file, the header is defined. It consists of two parts, the first one being the same across all encoding and the second being specific to the encoding used. The data content of the file starts right after the second END . The first line of the file's content, [% oCWorld:zCWorld 64513 0] , marks the start of a new object while the last line, [] marks the end of an object . Each object can contain multiple entries alongside other objects . Each entry has a name, a type and a value. This only applies to ascii and safe binary encodings.","title":"General Concepts"},{"location":"format/zen/#header","text":"The header of ZEN archives consists of two parts. The first has the same structure for every archive and the second differs between encodings. The first part of the header looks like this. Variable elements of the header have been replaced by <...> placeholders. Example ZEN archive header ZenGin Archive ver 1 <archiver> <encoding> saveGame <issave> date <timestamp> user <username> END Line breaks denote only one newline ( \\n ) character. The <archiver> is a string value, being either zCArchiverGeneric or zCArchiverBinSafe , in reference to the names of the ZEN archive parser classes in the original source code. <encoding> specifies the type of archive in the file. It is either ASCII (for ascii encoded archives), BINARY (for binary encoded archives) or BIN_SAFE (for safe binary encoded archives). If the archive is a save game file <issave> is set to 1 , otherwise it is 0 . <timestamp> denotes the date and time the archive was created. It follows the strptime format %d.%m.%Y %H:%M:%S . <username> is the name of the user (originally the windows account name) the archive was created by. For save games this contains the name of the user who saved the game. Refer to the example above for a filled-out version of the header. The encoding-specific headers follow directly after the END\\n line of the first header as can be seen in the example.","title":"Header"},{"location":"format/zen/#objects","text":"Objects in ZEN archives consist of an object name , a class name , a version identifier and an index . The object name is used to describe a unique sub-object of another while the class name is used to identify the type of the object. A ZEN archive object [visual zCParticleFX 0 6] describes a specific sub-object visual of type zCParticleFX meaning it has a set of entries consistent with the definition of a zCParticleFX . Objects without an object name just contain a % instead. Objects always end with [] . Note This behavior can be seen in the example above . Every object with the class name zCVob has the same set of entries as shown in the example. Danger The object name must be unique within each sub-object. A ZEN archive like this is invalid. [% oCWorld:zCWorld 64513 0] [VobTree % 0 0] [] [VobTree % 0 0] [] [] Class names originally referenced a specific class in C++-code. These classes were polymorphic so an object with a class name zCVobLight:zCVob contains both entries of type zCVob and zCVobLight . The entries of the super-class always precede the entries of the subclass, so the zCVobLight:zCVob would first contain all entries of zCVob and then all entries of zCVobLight . Objects without a class name just contain a % instead. Warning Class and object names may not contain spaces. The version of an object is a 32-bit unsigned number which denotes the version of the bottom-most subclass. The version of object [% oCMobInter:oCMOB:zCVob 35585 0] would be 35585 . This version, however, only refers to the oCMobInter -part. Danger This leads to issues when trying to determine whether an object uses the Gothic or the Gothic II definition. If the structure for oCMobInter did not change between the games, the version will be the same. This is not necessarily true for zVob though. Its definition might have changed but this change is not reflected in the version field of the object. The index field of the object is a 32-bit unsigned number which increments for every object with a class name in the archive. In the example this can be seen with the objects [% oCWorld:zCWorld 64513 0] and [% zCVob 39168 1] . Objects without a class name have an index of 0 .","title":"Objects"},{"location":"format/zen/#entries","text":"The concept of entries only really applies to archives with ascii or safe binary encoding. An entry originally represented a field in a C++-class which defined an object . For this reason, each entry has a name, a type and a value. The following entry types are supported: Type Name Type ID 1 Description string 1 ISO-8859-1 encoded text int 2 A 32-bit signed integer float 3 An IEEE 754 floating-point number byte 4 An 8-bit unsigned integer word 5 An 16-bit unsigned integer bool 6 An boolean value 2 vec3 7 A set of 3 IEEE 754 floating-point numbers color 8 A set of 4 8-bit unsigned integers raw 9 A set of an arbitrary amount of 8-bit unsigned integers rawFloat 16 A set of an arbitrary amount of IEEE 754 floating-point numbers enum 17 A 32-bit unsigned integer 3 hash 18 A 32-bit unsigned integer; specific to the safe binary encoding","title":"Entries"},{"location":"format/zen/#ascii","text":"ASCII-archives are human-readable ZEN archives, comparable to JSON. Contrary to its name, the file is not actually using the ASCII text encoding. Rather these files are encoded in ISO-8859-1 or alternatively Windows-1252 (because the characters used are encoded identically). ASCII ZEN-archives use a line-based format. Every line after the header contains exactly one object start statement, entry statement or object end token. Leading whitespace is ignored.","title":"ASCII"},{"location":"format/zen/#header_1","text":"The encoding specific header for the ASCII -encoding looks like this. Variable elements of the header have been replaced by <...> placeholders. objects <count> END <count> denotes the total number of objects in the archive. Refer to the example above for a filled-out version of the header.","title":"Header"},{"location":"format/zen/#objects_1","text":"As stated above, objects in ASCII-ZENs start with a line [% oCWorld:zCWorld 64513 0] defined as [<object name> <class name> <version> <index>] . This is explained further in the section about objects .","title":"Objects"},{"location":"format/zen/#entries_1","text":"Entries in ASCII-ZENs follow the format <name>:<type>=<value> where <name> is a C++ identifier, <type> is one of the type names mentioned in the entries section with the exclusion of the hash type. <value> depends on the given type. It has the following formats: Type Name Format Regex Example string An unlimited number of characters excluding newline characters ^[^\\n\\r]* field=string:This is a string int A decimal 32-bit integer ^[+-]?\\d+$ field=int:199 float A decimal floating point value with decimal separator . ^[+-]?(\\d+\\.)?\\d+$ field=float:-1.0 byte A decimal 8-bit unsigned integer ^\\d{1,3}$ field=byte:255 word A decimal 16-bit unsigned integer ^\\d+$ field=word:1001 bool A decimal 1-bit integer ^[01]$ field=bool:1 vec3 A set of three floating point values ^[+-]?(\\d+\\.)?\\d+ [+-]?(\\d+\\.)?\\d+ [+-]?(\\d+\\.)?\\d+$ field=vec3:1.0 -0.1 +100 color A set of four 8-bit unsigned integers ^\\d{1,3} \\d{1,3} \\d{1,3} \\d{1,3}$ field=color:100 0 255 12 raw An unlimited number of hexadecimal bytes ^([0-9A-Fa-f]{2})* field=raw:0fac3256b1 rawFloat An unlimited number of floating point values ^([+-]?(\\d+\\.)?\\d+ )* field=rawFloat:1.0 -100 enum A decimal 32-bit unsigned integer ^\\d+$ field=enum:10","title":"Entries"},{"location":"format/zen/#binary","text":"Binary archives are little more than containers for raw bytes. They don't actually contain key-value pairs and they don't allow for nesting objects.","title":"Binary"},{"location":"format/zen/#header_2","text":"The encoding specific header for the Binary -encoding is the same as that of the ascii encoding. Variable elements of the header have been replaced by <...> placeholders. objects <count> END <count> denotes the total number of objects in the archive.","title":"Header"},{"location":"format/zen/#objects_2","text":"Objects in binary ZENs don't work like they do in the ascii and safe binary encodings. No object end marker is stored and the beginning of an object does not follow the same format. Binary ZEN object begin structure #pragma pack(push, 1) struct zen_object_begin { uint32_t object_size ; // (1) uint16_t version ; // (2) uint32_t index ; // (3) char * object_name ; // Note: (4) char * class_name ; // Note: (5) }; #pragma pack(pop) Contains the size of the object in bytes, including the header. The version number of the object as described in Objects The index of the object as described in Objects The object name of the object as described in Objects . This insinuates that the string ends with a null-termination character ( \\0 ). In fact, it ends with a newline character ( \\n ), however! The class name of the object as described in Objects . This insinuates that the string ends with a null-termination character ( \\0 ). In fact, it ends with a newline character ( \\n ), however!","title":"Objects"},{"location":"format/zen/#entries_2","text":"Binary ZENs just contains packed bytes with no added type annotations. This makes it very difficult to determine the layout of structures within it without having access to the original source code. To read an integer from a binary ZEN for example, the next four bytes are read in literally like this (assuming a little-endian architecture). Binary ZEN entry read scalar example int32_t zen_binary_read_int ( FILE * fp ) { int32_t value = 0 ; fread ( & value , sizeof ( value ), 1 , fp ); return value ; } On big-endian architectures, the value read would have to be transformed to little-endian afterwards. This method of extracting values from binary ZENs is also used for aggregate types, like the vec3 . Instead of reading just one float from the input, three are read like this. Binary ZEN entry read vector example typedef struct vec3 { float x ; float y ; float z ; } vec3_t ; vec3_t zen_binary_read_int ( FILE * fp ) { vec3_t value ; fread ( & value . x , sizeof ( float ), 1 , fp ); fread ( & value . y , sizeof ( float ), 1 , fp ); fread ( & value . z , sizeof ( float ), 1 , fp ); return value ; } Refer to the following chart for type sizes. Type Name C-equivalent Byte Count string char[] 1 * n int int32_t 4 float float 4 byte uint8_t 1 word uint16_t 2 bool uint8_t 1 vec3 struct { float, float, float } 4 * 3 color struct { uint8_t, uint8_t, uint8_t, uint8_t } 1 * 4 raw uint8_t[] 1 * n rawFloat float[] 4 * n enum uint32_t 4","title":"Entries"},{"location":"format/zen/#safe-binary","text":"Safe binary archives store binary values annotated with field types and names. They are the most prevalent types of archives and also the ones in which world data is stored. The values of entries as well as their prefixes are stored in a packed binary format. This encoding is not fully reverse-engineered.","title":"Safe Binary"},{"location":"format/zen/#header_3","text":"The header of safe binary archives is also binary and has the following structure. Safe binary ZEN header structure #pragma pack(push, 1) struct zen_binsafe_header { uint32_t bs_version ; // (1) uint32_t object_count ; // (2) uint32_t hash_table_offset ; // (3) }; #pragma pack(pop) A separate version identifier for the version of the safe binary encoding used. The total number of objects in the archive The offset of the hash table from the beginning of the file in bytes; discussed below. In addition to the secondary header, safe binary archives also contain a so-called hash table 4 which stores field name information. The hash table is a binary structure as well; it looks like this. Safe binary ZEN hash table structure #pragma pack(push, 1) struct zen_binsafe_hashtable_entry { uint16_t name_length ; // (1) uint16_t insertion_index ; // (2) uint32_t hash_value ; // (3) char name []; // (4) }; struct zen_binsafe_hashtable { uint32_t size ; // (5) zen_binsafe_hashtable_entry entries []; // (6) }; #pragma pack(pop) The length of the name string at the end of the structure. The index of this entry in the hashtable entries member array. The hash value of the entry. Its purpose is currently unknown. The name of the entry. This name is the field name of the entry as explained below. The number of entries in the hash table. Corresponds with the length of the entries member array. An array of all hash table entries; unordered.","title":"Header"},{"location":"format/zen/#objects_3","text":"In safe binary ZENs, objects are handled in almost the same way entries are. Objects definitions are preceded by the string type identifier \\x01 and a 16-bit string length value. The value of this string is the same as the object definition for ASCII-ZENs: Objects start with a line [% oCWorld:zCWorld 64513 0] defined as [<object name> <class name> <version> <index>] . This is explained further in the section about objects . A full object definition might look like this: \\x01\\x1B\\x00[% oCWorld:zCWorld 64513 0] . Note Note that objects are never preceded by a field name like entries are.","title":"Objects"},{"location":"format/zen/#entries_3","text":"Every entry in safe binary ZENs is preceded by a field name index and a type identifier including a length if applicable. File name indexes start with a \\x12 which is followed by a 32-bit unsigned integer, indicating an index into the hash table discussed above. The name of the hash table entry at that index is the name of the field. A boolean entry in this format might look like \\x12\\x01\\x00\\00\\x00\\x06\\x01\\x00\\x00\\x00 . It hashtable index is 1 and its value is true . Type IDs are always uint8_t s and hashtable indices are always uint32_t s. Reference the table below for all types in safe binary archives. Type Name Type ID Has Length? C-equivalent Byte Count string 1 Yes char[] 1 * n int 2 No int32_t 4 float 3 No float 4 byte 4 No uint8_t 1 word 5 No uint16_t 2 bool 6 No uint32_t 4 vec3 7 No struct { float, float, float } 4 * 3 color 8 No struct { uint8_t, uint8_t, uint8_t, uint8_t } 1 * 4 raw 9 Yes uint8_t[] 1 * n rawFloat 16 Yes float[] 4 * n enum 17 No uint32_t 4 Note Entries with a length prefix, are encoded like this: \\x12\\x01\\x00\\00\\x00\\x01\\x0D\\x00Hello, world! . It hashtable index is 1 , its length is 0x0D and its value is Hello, World! . Note that the length is always a uint16_t and always follows directly after the type ID. The type index is relevant only for safe binary encoded archives. \u21a9 The actual representation of this value changes between encodings. With the safe binary encoding a boolean value is represented as a 32-bit unsigned integer while it is represented as an 8-bit integer in the binary encoding. \u21a9 Enums represent an actual enumeration value in C++-code. \u21a9 The origin of that name is unknown. It has been used in ZenLib to describe this element of the format. \u21a9","title":"Entries"},{"location":"miscellaneous/chunked/","text":"The chunked binary format Multiple different file formats use a special chunk based format for identifying separate parts of binary files. This documentation calls this format Chunked Binary . Important Chunked Binary files are binary files which are always encoded with the little-endian byte order. The number 0xCAFEBABE will be represented as BE BA FE CA when viewing the file in a hex editor. With this format, a binary file is split up into sections (called chunks) which each contain a separate kind of data. For a mesh, for example, there is a section containing general information, one containing the vertex position data and one with polygon data. The structure of this format can be roughly summed up as follows. Chunked binary structure #pragma pack(push, 1) typedef struct chunked_binary_chunk { uint16_t chunk_id ; // (1) uint32_t chunk_size ; // (2) uint8_t data []; // (3) } chunked_binary_chunk_t ; struct chunked_binary { chunked_binary_chunk_t chunks []; // (4) }; #pragma push(pop) The chunk ID depends on the format of file being parsed. It is noted alongside the documentation of the format. The number of bytes in the data section of the chunk. An array of length chunk_size containing the raw data of the chunk. The format of this data is specific to the format of the file being parsed. The documentation of that format describes the actual content of these sections. The entire input is filled with chunks. There are no excess bytes at the end.","title":"The chunked binary format"},{"location":"miscellaneous/chunked/#the-chunked-binary-format","text":"Multiple different file formats use a special chunk based format for identifying separate parts of binary files. This documentation calls this format Chunked Binary . Important Chunked Binary files are binary files which are always encoded with the little-endian byte order. The number 0xCAFEBABE will be represented as BE BA FE CA when viewing the file in a hex editor. With this format, a binary file is split up into sections (called chunks) which each contain a separate kind of data. For a mesh, for example, there is a section containing general information, one containing the vertex position data and one with polygon data. The structure of this format can be roughly summed up as follows. Chunked binary structure #pragma pack(push, 1) typedef struct chunked_binary_chunk { uint16_t chunk_id ; // (1) uint32_t chunk_size ; // (2) uint8_t data []; // (3) } chunked_binary_chunk_t ; struct chunked_binary { chunked_binary_chunk_t chunks []; // (4) }; #pragma push(pop) The chunk ID depends on the format of file being parsed. It is noted alongside the documentation of the format. The number of bytes in the data section of the chunk. An array of length chunk_size containing the raw data of the chunk. The format of this data is specific to the format of the file being parsed. The documentation of that format describes the actual content of these sections. The entire input is filled with chunks. There are no excess bytes at the end.","title":"The chunked binary format"}]}